/**
 * react-ranger
 *
 * Copyright (c) TanStack
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('react')) :
  typeof define === 'function' && define.amd ? define(['exports', 'react'], factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.ReactRanger = {}, global.React));
})(this, (function (exports, React) { 'use strict';

  function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = Object.create(null);
    if (e) {
      Object.keys(e).forEach(function (k) {
        if (k !== 'default') {
          var d = Object.getOwnPropertyDescriptor(e, k);
          Object.defineProperty(n, k, d.get ? d : {
            enumerable: true,
            get: function () { return e[k]; }
          });
        }
      });
    }
    n["default"] = e;
    return Object.freeze(n);
  }

  var React__namespace = /*#__PURE__*/_interopNamespace(React);

  /**
   * ranger
   *
   * Copyright (c) TanStack
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   */
  const getBoundingClientRect = element => {
    const rect = element.getBoundingClientRect();
    return {
      left: Math.ceil(rect.left),
      width: Math.ceil(rect.width)
    };
  };
  const sortNumList = arr => [...arr].map(Number).sort((a, b) => a - b);
  const linearInterpolator = {
    getPercentageForValue: (val, min, max) => {
      return Math.max(0, Math.min(100, (val - min) / (max - min) * 100));
    },
    getValueForClientX: (clientX, trackDims, min, max) => {
      const {
        left,
        width
      } = trackDims;
      const percentageValue = (clientX - left) / width;
      const value = (max - min) * percentageValue;
      return value + min;
    }
  };

  class Ranger {
    sortedValues = [];
    rangerElement = null;
    constructor(opts) {
      this.setOptions(opts);
    }
    setOptions(opts) {
      Object.entries(opts).forEach(([key, value]) => {
        if (typeof value === 'undefined') delete opts[key];
      });
      this.options = {
        debug: false,
        tickSize: 10,
        interpolator: linearInterpolator,
        onChange: () => {},
        ...opts
      };
    }
    _willUpdate = () => {
      const rangerElement = this.options.getRangerElement();
      if (this.rangerElement !== rangerElement) {
        this.rangerElement = rangerElement;
      }
    };
    getValueForClientX = clientX => {
      const trackDims = getBoundingClientRect(this.rangerElement);
      return this.options.interpolator.getValueForClientX(clientX, trackDims, this.options.min, this.options.max);
    };
    getNextStep = (val, direction) => {
      const {
        min,
        max
      } = this.options;
      if ('steps' in this.options) {
        const {
          steps
        } = this.options;
        let currIndex = steps.indexOf(val);
        let nextIndex = currIndex + direction;
        if (nextIndex >= 0 && nextIndex < steps.length) {
          return steps[nextIndex];
        } else {
          return val;
        }
      } else {
        let nextVal = val + this.options.stepSize * direction;
        if (nextVal >= min && nextVal <= max) {
          return nextVal;
        } else {
          return val;
        }
      }
    };
    roundToStep = val => {
      const {
        min,
        max
      } = this.options;
      let left = min;
      let right = max;
      if ('steps' in this.options) {
        this.options.steps.forEach(step => {
          if (step <= val && step > left) {
            left = step;
          }
          if (step >= val && step < right) {
            right = step;
          }
        });
      } else {
        const {
          stepSize
        } = this.options;
        while (left < val && left + stepSize < val) {
          left += stepSize;
        }
        right = Math.min(left + stepSize, max);
      }
      if (val - left < right - val) {
        return left;
      }
      return right;
    };
    handleDrag = e => {
      if (this.activeHandleIndex === undefined) {
        return;
      }
      const clientX = e.type === 'touchmove' ? e.changedTouches[0].clientX : e.clientX;
      const newValue = this.getValueForClientX(clientX);
      const newRoundedValue = this.roundToStep(newValue);
      this.sortedValues = [...this.options.values.slice(0, this.activeHandleIndex), newRoundedValue, ...this.options.values.slice(this.activeHandleIndex + 1)];
      if (this.options.onDrag) {
        this.options.onDrag(this);
      } else {
        this.tempValues = this.sortedValues;
        this.options.rerender();
      }
    };
    handleKeyDown = (e, i) => {
      const {
        values
      } = this.options;

      // Left Arrow || Right Arrow
      if (e.keyCode === 37 || e.keyCode === 39) {
        this.activeHandleIndex = i;
        const direction = e.keyCode === 37 ? -1 : 1;
        const newValue = this.getNextStep(values[i], direction);
        const newValues = [...values.slice(0, i), newValue, ...values.slice(i + 1)];
        this.sortedValues = sortNumList(newValues);
        if (this.options.onChange) {
          this.options.onChange(this);
        }
      }
    };
    handlePress = (_e, i) => {
      this.activeHandleIndex = i;
      this.options.rerender();
      const handleRelease = () => {
        const {
          tempValues,
          handleDrag
        } = this;
        document.removeEventListener('mousemove', handleDrag);
        document.removeEventListener('touchmove', handleDrag);
        document.removeEventListener('mouseup', handleRelease);
        document.removeEventListener('touchend', handleRelease);
        this.sortedValues = sortNumList(tempValues || this.options.values);
        if (this.options.onChange) {
          this.options.onChange(this);
        }
        if (this.options.onDrag) {
          this.options.onDrag(this);
        }
        this.activeHandleIndex = undefined;
        this.tempValues = undefined;
        this.options.rerender();
      };
      const {
        handleDrag
      } = this;
      document.addEventListener('mousemove', handleDrag);
      document.addEventListener('touchmove', handleDrag);
      document.addEventListener('mouseup', handleRelease);
      document.addEventListener('touchend', handleRelease);
    };
    getPercentageForValue = val => this.options.interpolator.getPercentageForValue(val, this.options.min, this.options.max);
    getTicks = () => {
      let ticks = [];
      if (this.options.ticks) {
        ticks = [...this.options.ticks];
      } else if ('steps' in this.options) {
        ticks = [...this.options.steps];
      } else {
        ticks = [this.options.min];
        while (ticks[ticks.length - 1] < this.options.max - this.options.tickSize) {
          ticks.push(ticks[ticks.length - 1] + this.options.tickSize);
        }
        ticks.push(this.options.max);
      }
      return ticks.map((value, i) => ({
        value,
        key: i,
        percentage: this.getPercentageForValue(value)
      }));
    };
    getSteps = () => {
      const values = sortNumList(this.tempValues || this.options.values);
      return [...values, this.options.max].map((value, i) => {
        const previousValue = values[i - 1];
        const leftValue = previousValue !== undefined ? previousValue : this.options.min;
        const left = this.getPercentageForValue(leftValue);
        const width = this.getPercentageForValue(value) - left;
        return {
          left,
          width
        };
      });
    };
    handles = () => {
      return (this.tempValues || this.options.values).map((value, i) => ({
        value,
        isActive: i === this.activeHandleIndex,
        onKeyDownHandler: e => {
          this.handleKeyDown(e, i);
        },
        onMouseDownHandler: e => {
          this.handlePress(e, i);
        },
        onTouchStart: e => {
          this.handlePress(e, i);
        }
      }));
    };
  }

  const useIsomorphicLayoutEffect = typeof window !== 'undefined' ? React__namespace.useLayoutEffect : React__namespace.useEffect;
  function useRanger(options) {
    const rerender = React__namespace.useReducer(() => ({}), {})[1];
    const resolvedOptions = {
      ...options,
      rerender,
      onChange: instance => {
        rerender();
        options.onChange?.(instance);
      }
    };
    const [instance] = React__namespace.useState(() => new Ranger(resolvedOptions));
    instance.setOptions(resolvedOptions);
    useIsomorphicLayoutEffect(() => {
      return instance._willUpdate();
    });
    return instance;
  }

  exports.Ranger = Ranger;
  exports.useRanger = useRanger;

  Object.defineProperty(exports, '__esModule', { value: true });

}));
//# sourceMappingURL=index.development.js.map
