{"version":3,"file":"index.production.js","sources":["../../src/utils.ts","../../src/index.ts"],"sourcesContent":["export const getBoundingClientRect = (element: any) => {\n  const rect = element.getBoundingClientRect()\n  return {\n    left: Math.ceil(rect.left),\n    width: Math.ceil(rect.width),\n  }\n}\n\nexport const sortNumList = (arr: ReadonlyArray<number | string>) =>\n  [...arr].map(Number).sort((a, b) => a - b)\n\nexport const linearInterpolator = {\n  getPercentageForValue: (val: number, min: number, max: number) => {\n    return Math.max(0, Math.min(100, ((val - min) / (max - min)) * 100))\n  },\n  getValueForClientX: (\n    clientX: number,\n    trackDims: { width: number; left: number },\n    min: number,\n    max: number,\n  ) => {\n    const { left, width } = trackDims\n    const percentageValue = (clientX - left) / width\n    const value = (max - min) * percentageValue\n    return value + min\n  },\n}\n","import { linearInterpolator, getBoundingClientRect, sortNumList } from './utils'\n\nexport type RangerChangeEvent<TTrackElement> = (\n  instance: Ranger<TTrackElement>,\n) => void\n\nexport type RangerInterpolator = {\n  getPercentageForValue: (val: number, min: number, max: number) => number\n  getValueForClientX: (\n    clientX: number,\n    trackDims: { width: number; left: number },\n    min: number,\n    max: number,\n  ) => number\n}\n\nexport type RangerClassConfig<TTrackElement = unknown> = {\n  getRangerElement: () => TTrackElement | null\n  values: ReadonlyArray<number>\n\n  min: number\n  max: number\n\n  tickSize: number\n  ticks?: ReadonlyArray<number>\n\n  interpolator: RangerInterpolator\n  onChange: RangerChangeEvent<TTrackElement>\n  onDrag?: RangerChangeEvent<TTrackElement>\n\n  rerender: () => void\n  debug: boolean\n} & ({ stepSize: number } | { steps: ReadonlyArray<number> })\n\nexport type RangerConfig<TTrackElement = unknown> = Omit<\n  RangerClassConfig<TTrackElement>,\n  'tickSize' | 'interpolator' | 'onChange' | 'debug'\n> & {\n  tickSize?: number\n  interpolator?: RangerInterpolator\n  onChange?: RangerChangeEvent<TTrackElement>\n  debug?: boolean\n} & ({ stepSize: number } | { steps: ReadonlyArray<number> })\n\nexport type RangerOptions<TTrackElement = unknown> = Omit<\n  RangerConfig<TTrackElement>,\n  'rerender'\n> &\n  ({ stepSize: number } | { steps: ReadonlyArray<number> })\n\nexport class Ranger<TTrackElement = unknown> {\n  activeHandleIndex: number | undefined\n  tempValues: ReadonlyArray<number> | undefined\n  sortedValues: ReadonlyArray<number> = []\n\n  options!: RangerClassConfig<TTrackElement>\n\n  private rangerElement: TTrackElement | null = null\n\n  constructor(opts: RangerConfig<TTrackElement>) {\n    this.setOptions(opts)\n  }\n\n  setOptions(opts: RangerConfig<TTrackElement>) {\n    Object.entries(opts).forEach(([key, value]) => {\n      if (typeof value === 'undefined') delete (opts as any)[key]\n    })\n\n    this.options = {\n      debug: false,\n      tickSize: 10,\n      interpolator: linearInterpolator,\n      onChange: () => {},\n      ...opts,\n    }\n  }\n\n  _willUpdate = () => {\n    const rangerElement = this.options.getRangerElement()\n\n    if (this.rangerElement !== rangerElement) {\n      this.rangerElement = rangerElement\n    }\n  }\n\n  getValueForClientX = (clientX: number) => {\n    const trackDims = getBoundingClientRect(this.rangerElement)\n    return this.options.interpolator.getValueForClientX(\n      clientX,\n      trackDims,\n      this.options.min,\n      this.options.max,\n    )\n  }\n\n  getNextStep = (val: number, direction: number): number => {\n    const { min, max } = this.options\n\n    if ('steps' in this.options) {\n      const { steps } = this.options\n      let currIndex = steps.indexOf(val)\n      let nextIndex = currIndex + direction\n      if (nextIndex >= 0 && nextIndex < steps.length) {\n        return steps[nextIndex] as number\n      } else {\n        return val\n      }\n    } else {\n      let nextVal = val + this.options.stepSize * direction\n      if (nextVal >= min && nextVal <= max) {\n        return nextVal\n      } else {\n        return val\n      }\n    }\n  }\n\n  roundToStep = (val: number) => {\n    const { min, max } = this.options\n\n    let left = min\n    let right = max\n    if ('steps' in this.options) {\n      this.options.steps.forEach((step) => {\n        if (step <= val && step > left) {\n          left = step\n        }\n        if (step >= val && step < right) {\n          right = step\n        }\n      })\n    } else {\n      const { stepSize } = this.options\n      while (left < val && left + stepSize < val) {\n        left += stepSize\n      }\n\n      right = Math.min(left + stepSize, max)\n    }\n\n    if (val - left < right - val) {\n      return left\n    }\n    return right\n  }\n\n  handleDrag = (e: any) => {\n    if (this.activeHandleIndex === undefined) {\n      return\n    }\n\n    const clientX =\n      e.type === 'touchmove' ? e.changedTouches[0].clientX : e.clientX\n    const newValue = this.getValueForClientX(clientX)\n    const newRoundedValue = this.roundToStep(newValue)\n\n    this.sortedValues = [\n      ...this.options.values.slice(0, this.activeHandleIndex),\n      newRoundedValue,\n      ...this.options.values.slice(this.activeHandleIndex + 1),\n    ]\n\n    if (this.options.onDrag) {\n      this.options.onDrag(this)\n    } else {\n      this.tempValues = this.sortedValues\n      this.options.rerender()\n    }\n  }\n\n  handleKeyDown = (e: KeyboardEvent, i: number) => {\n    const { values } = this.options\n\n    // Left Arrow || Right Arrow\n    if (e.keyCode === 37 || e.keyCode === 39) {\n      this.activeHandleIndex = i\n      const direction = e.keyCode === 37 ? -1 : 1\n      const newValue = this.getNextStep(values[i] as number, direction)\n      const newValues = [\n        ...values.slice(0, i),\n        newValue,\n        ...values.slice(i + 1),\n      ]\n      this.sortedValues = sortNumList(newValues)\n      if (this.options.onChange) {\n        this.options.onChange(this)\n      }\n    }\n  }\n\n  handlePress = (_e: any, i: number) => {\n    this.activeHandleIndex = i\n    this.options.rerender()\n\n    const handleRelease = () => {\n      const { tempValues, handleDrag } = this\n\n      document.removeEventListener('mousemove', handleDrag)\n      document.removeEventListener('touchmove', handleDrag)\n      document.removeEventListener('mouseup', handleRelease)\n      document.removeEventListener('touchend', handleRelease)\n      this.sortedValues = sortNumList(tempValues || this.options.values)\n      if (this.options.onChange) {\n        this.options.onChange(this)\n      }\n      if (this.options.onDrag) {\n        this.options.onDrag(this)\n      }\n      this.activeHandleIndex = undefined\n      this.tempValues = undefined\n      this.options.rerender()\n    }\n    const { handleDrag } = this\n    document.addEventListener('mousemove', handleDrag)\n    document.addEventListener('touchmove', handleDrag)\n    document.addEventListener('mouseup', handleRelease)\n    document.addEventListener('touchend', handleRelease)\n  }\n\n  getPercentageForValue = (val: number) =>\n    this.options.interpolator.getPercentageForValue(\n      val,\n      this.options.min,\n      this.options.max,\n    )\n\n  getTicks = () => {\n    let ticks: Array<number> = []\n    if (this.options.ticks) {\n      ticks = [...this.options.ticks]\n    } else if ('steps' in this.options) {\n      ticks = [...this.options.steps]\n    } else {\n      ticks = [this.options.min]\n      while (\n        (ticks[ticks.length - 1] as number) <\n        this.options.max - this.options.tickSize\n      ) {\n        ticks.push((ticks[ticks.length - 1] as number) + this.options.tickSize)\n      }\n      ticks.push(this.options.max)\n    }\n\n    return ticks.map((value, i) => ({\n      value,\n      key: i,\n      percentage: this.getPercentageForValue(value),\n    }))\n  }\n\n  getSteps = () => {\n    const values = sortNumList(this.tempValues || this.options.values)\n\n    return [...values, this.options.max].map((value, i) => {\n      const previousValue = values[i - 1]\n      const leftValue =\n        previousValue !== undefined ? previousValue : this.options.min\n      const left = this.getPercentageForValue(leftValue)\n      const width = this.getPercentageForValue(value) - left\n      return {\n        left,\n        width,\n      }\n    })\n  }\n\n  handles = () => {\n    return (this.tempValues || this.options.values).map((value, i) => ({\n      value,\n      isActive: i === this.activeHandleIndex,\n      onKeyDownHandler: (e: any) => {\n        this.handleKeyDown(e, i)\n      },\n      onMouseDownHandler: (e: any) => {\n        this.handlePress(e, i)\n      },\n      onTouchStart: (e: any) => {\n        this.handlePress(e, i)\n      },\n    }))\n  }\n}\n"],"names":["sortNumList","arr","map","Number","sort","a","b","linearInterpolator","getPercentageForValue","val","min","max","Math","getValueForClientX","clientX","trackDims","left","width","sortedValues","rangerElement","constructor","opts","this","setOptions","Object","entries","forEach","key","value","options","debug","tickSize","interpolator","onChange","_willUpdate","getRangerElement","element","rect","getBoundingClientRect","ceil","getNextStep","direction","steps","nextIndex","indexOf","length","nextVal","stepSize","roundToStep","right","step","handleDrag","e","undefined","activeHandleIndex","type","changedTouches","newValue","newRoundedValue","values","slice","onDrag","tempValues","rerender","handleKeyDown","i","keyCode","newValues","handlePress","_e","handleRelease","document","removeEventListener","addEventListener","getTicks","ticks","push","percentage","getSteps","previousValue","leftValue","handles","isActive","onKeyDownHandler","onMouseDownHandler","onTouchStart"],"mappings":";;;;;;;;;;8OAAO,MAQMA,EAAeC,GAC1B,IAAIA,GAAKC,IAAIC,QAAQC,MAAK,CAACC,EAAGC,IAAMD,EAAIC,IAE7BC,EAAqB,CAChCC,sBAAuB,CAACC,EAAaC,EAAaC,IACzCC,KAAKD,IAAI,EAAGC,KAAKF,IAAI,KAAOD,EAAMC,IAAQC,EAAMD,GAAQ,MAEjEG,mBAAoB,CAClBC,EACAC,EACAL,EACAC,KAEA,MAAMK,KAAEA,EAAIC,MAAEA,GAAUF,EAGxB,OADeJ,EAAMD,KADII,EAAUE,GAAQC,GAE5BP,CAAG,YC0Bf,MAGLQ,aAAsC,GAI9BC,cAAsC,KAE9CC,YAAYC,GACVC,KAAKC,WAAWF,EAClB,CAEAE,WAAWF,GACTG,OAAOC,QAAQJ,GAAMK,SAAQ,EAAEC,EAAKC,WACb,IAAVA,UAA+BP,EAAaM,EAAI,IAG7DL,KAAKO,QAAU,CACbC,OAAO,EACPC,SAAU,GACVC,aAAczB,EACd0B,SAAU,UACPZ,EAEP,CAEAa,YAAc,KACZ,MAAMf,EAAgBG,KAAKO,QAAQM,mBAE/Bb,KAAKH,gBAAkBA,IACzBG,KAAKH,cAAgBA,EACvB,EAGFN,mBAAsBC,IACpB,MAAMC,EDtF4BqB,KACpC,MAAMC,EAAOD,EAAQE,wBACrB,MAAO,CACLtB,KAAMJ,KAAK2B,KAAKF,EAAKrB,MACrBC,MAAOL,KAAK2B,KAAKF,EAAKpB,OACvB,ECiFmBqB,CAAsBhB,KAAKH,eAC7C,OAAOG,KAAKO,QAAQG,aAAanB,mBAC/BC,EACAC,EACAO,KAAKO,QAAQnB,IACbY,KAAKO,QAAQlB,IACd,EAGH6B,YAAc,CAAC/B,EAAagC,KAC1B,MAAM/B,IAAEA,EAAGC,IAAEA,GAAQW,KAAKO,QAE1B,GAAI,UAAWP,KAAKO,QAAS,CAC3B,MAAMa,MAAEA,GAAUpB,KAAKO,QACvB,IACIc,EADYD,EAAME,QAAQnC,GACFgC,EAC5B,OAAIE,GAAa,GAAKA,EAAYD,EAAMG,OAC/BH,EAAMC,GAENlC,CAEX,CAAO,CACL,IAAIqC,EAAUrC,EAAMa,KAAKO,QAAQkB,SAAWN,EAC5C,OAAIK,GAAWpC,GAAOoC,GAAWnC,EACxBmC,EAEArC,CAEX,GAGFuC,YAAevC,IACb,MAAMC,IAAEA,EAAGC,IAAEA,GAAQW,KAAKO,QAE1B,IAAIb,EAAON,EACPuC,EAAQtC,EACZ,GAAI,UAAWW,KAAKO,QAClBP,KAAKO,QAAQa,MAAMhB,SAASwB,IACtBA,GAAQzC,GAAOyC,EAAOlC,IACxBA,EAAOkC,GAELA,GAAQzC,GAAOyC,EAAOD,IACxBA,EAAQC,EACV,QAEG,CACL,MAAMH,SAAEA,GAAazB,KAAKO,QAC1B,KAAOb,EAAOP,GAAOO,EAAO+B,EAAWtC,GACrCO,GAAQ+B,EAGVE,EAAQrC,KAAKF,IAAIM,EAAO+B,EAAUpC,EACpC,CAEA,OAAIF,EAAMO,EAAOiC,EAAQxC,EAChBO,EAEFiC,CAAK,EAGdE,WAAcC,IACZ,QAA+BC,IAA3B/B,KAAKgC,kBACP,OAGF,MAAMxC,EACO,cAAXsC,EAAEG,KAAuBH,EAAEI,eAAe,GAAG1C,QAAUsC,EAAEtC,QACrD2C,EAAWnC,KAAKT,mBAAmBC,GACnC4C,EAAkBpC,KAAK0B,YAAYS,GAEzCnC,KAAKJ,aAAe,IACfI,KAAKO,QAAQ8B,OAAOC,MAAM,EAAGtC,KAAKgC,mBACrCI,KACGpC,KAAKO,QAAQ8B,OAAOC,MAAMtC,KAAKgC,kBAAoB,IAGpDhC,KAAKO,QAAQgC,OACfvC,KAAKO,QAAQgC,OAAOvC,OAEpBA,KAAKwC,WAAaxC,KAAKJ,aACvBI,KAAKO,QAAQkC,WACf,EAGFC,cAAgB,CAACZ,EAAkBa,KACjC,MAAMN,OAAEA,GAAWrC,KAAKO,QAGxB,GAAkB,KAAduB,EAAEc,SAAgC,KAAdd,EAAEc,QAAgB,CACxC5C,KAAKgC,kBAAoBW,EACzB,MAAMxB,EAA0B,KAAdW,EAAEc,SAAkB,EAAI,EACpCT,EAAWnC,KAAKkB,YAAYmB,EAAOM,GAAcxB,GACjD0B,EAAY,IACbR,EAAOC,MAAM,EAAGK,GACnBR,KACGE,EAAOC,MAAMK,EAAI,IAEtB3C,KAAKJ,aAAelB,EAAYmE,GAC5B7C,KAAKO,QAAQI,UACfX,KAAKO,QAAQI,SAASX,KAE1B,GAGF8C,YAAc,CAACC,EAASJ,KACtB3C,KAAKgC,kBAAoBW,EACzB3C,KAAKO,QAAQkC,WAEb,MAAMO,EAAgB,KACpB,MAAMR,WAAEA,EAAUX,WAAEA,GAAe7B,KAEnCiD,SAASC,oBAAoB,YAAarB,GAC1CoB,SAASC,oBAAoB,YAAarB,GAC1CoB,SAASC,oBAAoB,UAAWF,GACxCC,SAASC,oBAAoB,WAAYF,GACzChD,KAAKJ,aAAelB,EAAY8D,GAAcxC,KAAKO,QAAQ8B,QACvDrC,KAAKO,QAAQI,UACfX,KAAKO,QAAQI,SAASX,MAEpBA,KAAKO,QAAQgC,QACfvC,KAAKO,QAAQgC,OAAOvC,MAEtBA,KAAKgC,uBAAoBD,EACzB/B,KAAKwC,gBAAaT,EAClB/B,KAAKO,QAAQkC,UAAU,GAEnBZ,WAAEA,GAAe7B,KACvBiD,SAASE,iBAAiB,YAAatB,GACvCoB,SAASE,iBAAiB,YAAatB,GACvCoB,SAASE,iBAAiB,UAAWH,GACrCC,SAASE,iBAAiB,WAAYH,EAAc,EAGtD9D,sBAAyBC,GACvBa,KAAKO,QAAQG,aAAaxB,sBACxBC,EACAa,KAAKO,QAAQnB,IACbY,KAAKO,QAAQlB,KAGjB+D,SAAW,KACT,IAAIC,EAAuB,GAC3B,GAAIrD,KAAKO,QAAQ8C,MACfA,EAAQ,IAAIrD,KAAKO,QAAQ8C,YACpB,GAAI,UAAWrD,KAAKO,QACzB8C,EAAQ,IAAIrD,KAAKO,QAAQa,WACpB,CAEL,IADAiC,EAAQ,CAACrD,KAAKO,QAAQnB,KAEnBiE,EAAMA,EAAM9B,OAAS,GACtBvB,KAAKO,QAAQlB,IAAMW,KAAKO,QAAQE,UAEhC4C,EAAMC,KAAMD,EAAMA,EAAM9B,OAAS,GAAgBvB,KAAKO,QAAQE,UAEhE4C,EAAMC,KAAKtD,KAAKO,QAAQlB,IAC1B,CAEA,OAAOgE,EAAMzE,KAAI,CAAC0B,EAAOqC,KAAO,CAC9BrC,QACAD,IAAKsC,EACLY,WAAYvD,KAAKd,sBAAsBoB,MACtC,EAGLkD,SAAW,KACT,MAAMnB,EAAS3D,EAAYsB,KAAKwC,YAAcxC,KAAKO,QAAQ8B,QAE3D,MAAO,IAAIA,EAAQrC,KAAKO,QAAQlB,KAAKT,KAAI,CAAC0B,EAAOqC,KAC/C,MAAMc,EAAgBpB,EAAOM,EAAI,GAC3Be,OACc3B,IAAlB0B,EAA8BA,EAAgBzD,KAAKO,QAAQnB,IACvDM,EAAOM,KAAKd,sBAAsBwE,GAExC,MAAO,CACLhE,OACAC,MAHYK,KAAKd,sBAAsBoB,GAASZ,EAIjD,GACD,EAGJiE,QAAU,KACA3D,KAAKwC,YAAcxC,KAAKO,QAAQ8B,QAAQzD,KAAI,CAAC0B,EAAOqC,KAAO,CACjErC,QACAsD,SAAUjB,IAAM3C,KAAKgC,kBACrB6B,iBAAmB/B,IACjB9B,KAAK0C,cAAcZ,EAAGa,EAAE,EAE1BmB,mBAAqBhC,IACnB9B,KAAK8C,YAAYhB,EAAGa,EAAE,EAExBoB,aAAejC,IACb9B,KAAK8C,YAAYhB,EAAGa,EAAE"}