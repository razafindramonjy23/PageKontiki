import {
  useTheme
} from "./chunk-FT445BB5.js";
import {
  timelineBodyTheme,
  timelineHeaderTheme,
  timelineIconTheme,
  timelineItemTheme,
  timelineSeparatorTheme,
  timelineTheme
} from "./chunk-BAFDZUY3.js";

// src/components/timeline.tsx
import * as React from "react";
import { twMerge } from "tailwind-merge";
import { useMergeRefs } from "@floating-ui/react";
import { jsx } from "react/jsx-runtime";
var TimelineContext = React.createContext({
  value: "",
  setValue: () => {
  },
  color: "primary",
  mode: "timeline",
  orientation: "horizontal"
});
function TimelineRootBase({
  as,
  value,
  defaultValue,
  onValueChange,
  color,
  mode,
  orientation,
  className,
  children,
  ...props
}, ref) {
  const Component = as || "div";
  const contextTheme = useTheme();
  const theme = contextTheme?.timeline ?? timelineTheme;
  const defaultProps = theme?.defaultProps;
  const innerRef = React.useRef(null);
  const [innerValue, setInnerValue] = React.useState(defaultValue || "");
  value ??= innerValue;
  onValueChange ??= setInnerValue;
  mode ??= defaultProps?.mode ?? "timeline";
  color ??= defaultProps?.color ?? "primary";
  orientation ??= defaultProps?.orientation ?? "horizontal";
  React.useEffect(() => {
    const parentEl = innerRef?.current;
    if (parentEl && !value) {
      const children2 = Array.from(parentEl.children);
      const firstChild = children2[0];
      onValueChange?.(firstChild.dataset.value);
    }
  }, []);
  React.useEffect(() => {
    if (mode === "stepper") {
      const parentEl = innerRef?.current;
      if (parentEl) {
        const children2 = Array.from(parentEl.children);
        const currentEl = children2.find(
          (child) => child.dataset.value == value
        );
        const currentElIndex = children2.findIndex(
          (child) => child.dataset.value == value
        );
        const activeElIndex = children2.findIndex(
          (child) => child.dataset.active === "true"
        );
        const completedSteps = children2.filter(
          (_, index) => index < activeElIndex
        );
        const incompletedSteps = children2.filter(
          (_, index) => index > activeElIndex
        );
        completedSteps.forEach((step) => {
          step.dataset.completed = "true";
        });
        incompletedSteps.forEach((step) => {
          step.dataset.completed = "false";
        });
        if (currentElIndex === activeElIndex && currentEl) {
          currentEl.dataset.completed = "false";
        }
      }
    }
  }, [value]);
  const contextValue = React.useMemo(
    () => ({
      value,
      setValue: onValueChange,
      orientation,
      color,
      mode,
      parentRef: innerRef
    }),
    [value, onValueChange, orientation, color, mode]
  );
  const styles = twMerge(theme.baseStyle, className);
  const mergedRef = useMergeRefs([ref, innerRef]);
  return /* @__PURE__ */ jsx(
    Component,
    {
      ...props,
      ref: mergedRef,
      className: styles,
      "data-orientation": orientation,
      children: /* @__PURE__ */ jsx(TimelineContext.Provider, { value: contextValue, children })
    }
  );
}
TimelineRootBase.displayName = "MaterialTailwind.Timeline";
var TimelineRoot = React.forwardRef(TimelineRootBase);
function TimelineItemRoot({ as, value, className, disabled, children, ...props }, ref) {
  const Component = as || "div";
  const contextTheme = useTheme();
  const theme = contextTheme?.timelineItem ?? timelineItemTheme;
  const {
    mode,
    setValue,
    orientation,
    value: contextValue
  } = React.useContext(TimelineContext);
  const innerRef = React.useRef(null);
  value ??= React.useId();
  const isActive = contextValue == value || mode === "timeline";
  function onClick(event) {
    props?.onClick?.(event);
    if (mode === "stepper") {
      setValue?.(value);
    }
  }
  const styles = twMerge(theme.baseStyle, className);
  const mergedRef = useMergeRefs([ref, innerRef]);
  return /* @__PURE__ */ jsx(
    Component,
    {
      ...props,
      ref: mergedRef,
      onClick,
      "data-value": value,
      "data-active": isActive,
      "data-completed": isActive,
      "data-orientation": orientation,
      "aria-disabled": disabled,
      className: styles,
      children
    }
  );
}
TimelineItemRoot.displayName = "MaterialTailwind.TimelineItem";
var TimelineItem = React.forwardRef(TimelineItemRoot);
function TimelineHeaderRoot({ as, className, children, ...props }, ref) {
  const Component = as || "div";
  const contextTheme = useTheme();
  const theme = contextTheme?.timelineHeader ?? timelineHeaderTheme;
  const styles = twMerge(theme.baseStyle, className);
  return /* @__PURE__ */ jsx(Component, { ...props, ref, className: styles, children });
}
TimelineHeaderRoot.displayName = "MaterialTailwind.TimelineHeader";
var TimelineHeader = React.forwardRef(TimelineHeaderRoot);
function TimelineIconRoot({ as, className, children, ...props }, ref) {
  const Component = as || "span";
  const contextTheme = useTheme();
  const theme = contextTheme?.timelineIcon ?? timelineIconTheme;
  const { color } = React.useContext(TimelineContext);
  const styles = twMerge(theme.baseStyle, theme.color[color], className);
  return /* @__PURE__ */ jsx(Component, { ...props, ref, className: styles, children });
}
TimelineIconRoot.displayName = "MaterialTailwind.TimelineIcon";
var TimelineIcon = React.forwardRef(TimelineIconRoot);
function TimelineSeparatorRoot({ as, className, children, ...props }, ref) {
  const Component = as || "div";
  const contextTheme = useTheme();
  const theme = contextTheme?.timelineSeparator ?? timelineSeparatorTheme;
  const { orientation, color } = React.useContext(TimelineContext);
  const styles = twMerge(theme.baseStyle, theme.color[color], className);
  return /* @__PURE__ */ jsx(
    Component,
    {
      ...props,
      ref,
      "data-orientation": orientation,
      className: styles,
      children
    }
  );
}
TimelineSeparatorRoot.displayName = "MaterialTailwind.TimelineSeparator";
var TimelineSeparator = React.forwardRef(TimelineSeparatorRoot);
function TimelineBodyRoot({ as, className, children, ...props }, ref) {
  const Component = as || "div";
  const contextTheme = useTheme();
  const theme = contextTheme?.timelineBody ?? timelineBodyTheme;
  const { orientation } = React.useContext(TimelineContext);
  const styles = twMerge(theme.baseStyle, className);
  return /* @__PURE__ */ jsx(
    Component,
    {
      ...props,
      ref,
      className: styles,
      "data-orientation": orientation,
      children
    }
  );
}
TimelineBodyRoot.displayName = "MaterialTailwind.TimelineBody";
var TimelineBody = React.forwardRef(TimelineBodyRoot);
var Timeline = Object.assign(TimelineRoot, {
  Item: TimelineItem,
  Icon: TimelineIcon,
  Body: TimelineBody,
  Header: TimelineHeader,
  Separator: TimelineSeparator
});

export {
  TimelineContext,
  TimelineRoot,
  TimelineItem,
  TimelineHeader,
  TimelineIcon,
  TimelineSeparator,
  TimelineBody,
  Timeline
};
