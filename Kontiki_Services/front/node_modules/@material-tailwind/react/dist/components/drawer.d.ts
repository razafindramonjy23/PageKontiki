import * as _floating_ui_react from '@floating-ui/react';
import { FloatingFocusManagerProps, UseFloatingReturn, useInteractions } from '@floating-ui/react';
import * as react_jsx_runtime from 'react/jsx-runtime';
import * as React from 'react';
import { BaseProps } from '../types/general.js';

type FloatingType = Partial<UseFloatingReturn> & Partial<ReturnType<typeof useInteractions>>;
interface DrawerContextProps extends FloatingType {
    open?: boolean;
    setOpen?: React.Dispatch<React.SetStateAction<boolean>>;
}
interface DrawerRootProps {
    open?: boolean;
    onOpenChange?: React.Dispatch<React.SetStateAction<boolean>>;
    children: React.ReactNode;
}
declare function DrawerRoot({ open: controlledOpen, onOpenChange: setControlledOpen, children, }: DrawerRootProps): react_jsx_runtime.JSX.Element;
declare namespace DrawerRoot {
    var displayName: string;
}
type DrawerTriggerProps<T extends React.ElementType = "button"> = BaseProps<T>;
declare const DrawerTrigger: <T extends React.ElementType<any, keyof React.JSX.IntrinsicElements> = "button">(props: any) => JSX.Element;
type DrawerOverlayProps<T extends React.ElementType = "div"> = Omit<BaseProps<T, {
    lockScroll?: boolean;
}>, "as">;
declare const DrawerOverlay: <T extends React.ElementType<any, keyof React.JSX.IntrinsicElements> = "div">(props: DrawerOverlayProps<T> & {
    ref?: React.Ref<HTMLDivElement> | undefined;
}) => JSX.Element;
type DrawerPanelProps<T extends React.ElementType = "div"> = BaseProps<T, {
    placement?: "top" | "right" | "bottom" | "left";
} & Omit<FloatingFocusManagerProps, "context" | "children">>;
declare const DrawerPanel: <T extends React.ElementType<any, keyof React.JSX.IntrinsicElements> = "div">(props: {
    placement?: "right" | "bottom" | "top" | "left" | undefined;
} & Omit<FloatingFocusManagerProps<_floating_ui_react.ReferenceType>, "children" | "context"> & {
    as?: T | undefined;
} & Omit<React.PropsWithoutRef<React.ComponentProps<T>>, "as" | "order" | "disabled" | "placement" | "initialFocus" | "guards" | "returnFocus" | "modal" | "visuallyHiddenDismiss" | "closeOnFocusOut"> & {
    ref?: React.Ref<Element> | undefined;
}) => JSX.Element;
type DrawerDismissTriggerProps<T extends React.ElementType = "button"> = BaseProps<T>;
declare const DrawerDismissTrigger: <T extends React.ElementType<any, keyof React.JSX.IntrinsicElements> = "button">(props: any) => JSX.Element;
declare const Drawer: typeof DrawerRoot & {
    Trigger: <T extends React.ElementType<any, keyof React.JSX.IntrinsicElements> = "button">(props: any) => JSX.Element;
    Overlay: <T_1 extends React.ElementType<any, keyof React.JSX.IntrinsicElements> = "div">(props: DrawerOverlayProps<T_1> & {
        ref?: React.Ref<HTMLDivElement> | undefined;
    }) => JSX.Element;
    Panel: <T extends React.ElementType<any, keyof React.JSX.IntrinsicElements> = "div">(props: {
        placement?: "right" | "bottom" | "top" | "left" | undefined;
    } & Omit<FloatingFocusManagerProps<_floating_ui_react.ReferenceType>, "children" | "context"> & {
        as?: T | undefined;
    } & Omit<React.PropsWithoutRef<React.ComponentProps<T>>, "as" | "order" | "disabled" | "placement" | "initialFocus" | "guards" | "returnFocus" | "modal" | "visuallyHiddenDismiss" | "closeOnFocusOut"> & {
        ref?: React.Ref<Element> | undefined;
    }) => JSX.Element;
    DismissTrigger: <T_1 extends React.ElementType<any, keyof React.JSX.IntrinsicElements> = "button">(props: any) => JSX.Element;
};

export { Drawer, DrawerContextProps, DrawerDismissTrigger, DrawerDismissTriggerProps, DrawerOverlay, DrawerOverlayProps, DrawerPanel, DrawerPanelProps, DrawerRoot, DrawerRootProps, DrawerTrigger, DrawerTriggerProps, Drawer as default };
